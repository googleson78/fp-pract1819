### Моля прочетете [Haskell info]-то, секции `Домашни` (задължителна) и `Style guide` (препоръчителна)
### Конвенцията за именоване на файлове остава същата (все още се намира в главното [README.md], има и пример вече)

# Съждително смятане

Математическата логика е наука, породила се от нуждата за дефиниране на какво означава
"обективна истина" на изреченията които ползваме в математиката.

Тя се занимава с формализирането на това какво означава "твърдение" (формула) и придаване на тях "вернота", търсейки
"обективни" доказателства – такива, които се проверяват следвайки стъпки (алгоритъм), тоест от компютър.

Една от най-простите (и не особено силна) система за логика, която можем да разглеждаме се нарича "**Съждително смятане**".

В нея имаме променливи, с които целим да изразим твърдения, чиято истинност зависи от външни обстоятелства
и освен това добре познатите ви (от дискретни структури) логически оператори – отрицание, импликация, конюнкция и тн.

Съждителна (**propositional**) формула от първи ред дефинираме рекурсивно:

1. Всяка променлива `x` е съждителна формула сама по себе си.
2. Ако `φ` е съждителна формула, то и `¬φ` е съждителна формула.
3. Ако `φ` и `ψ` са съждителни формули, то `(φ σ ψ)` също е съждителна формула, където `σ ∈ {&, ∨, →}`.

В `Haskell`, можем да моделираме съждителните формули чрез следния тип данни (за кеф? ще сложим и константите `T` и `F`, които ще са със значение "истина" и "лъжа"):

```code
type Name = String

data Prop = Const Bool
          | Var Name
          | Not Prop
          | And Prop Prop
          | Or Prop Prop
          | Implies Prop Prop
```

Ще позволим произволни низове за имена на нашите променливи.

За да можем да използваме по-удобно инфиксно `Implies`, ще кажем че той е дясно асоциативен, използвайки
```haskell
infixr 7 `Implies`
```

Също така ще отбележим и приоритета на другите операции, за да ни е по-удобно за писане (по-малко скоби), следвайки установената конвенция за приоритет:
```haskell
infixl 9 `And`
infixl 8 `Or`
```

(Стандартно импликацията е дясноасоциативна, и приоритетите на операциите са
импликация < дизюнкция < конюнкция.)

Ето ви готина `Show` инстация, не е задължително да я ползвате, но мисля че улеснява нещата:
```haskell
instance Show Prop where
    show (Const b)          = if b then "T" else "F"
    show (Var x)            = x
    show (Not fi)           = '¬' : show fi
    show (fi `And` psi)     = show fi ++ " & " ++ show psi
    show (fi `Or` psi)      = "(" ++ show fi ++ " ∨ " ++ show psi ++ ")"
    show (fi `Implies` psi) = "(" ++ show fi ++ " → " ++ show psi ++ ")"
```

Сега можем спокойно да напишем
```haskell
> x = Var "x"
> y = Var "y"
> z = Var "z"
> x `And` y `Or` z
(x & y ∨ z)
> x `And` (y `Or` z)
x & (y ∨ z)
```

и да знаем че ще се интерпретира като хората (и ще изглежда хубаво освен това).


Две формули могат да са "синтактично" (структурно) равни. Това обикновено се бележи с `≡`, т.е. `φ ≡ ψ` и се дефинира рекурсивно:
1. Променливата `x` е синтактично равна на променливата `y`, тогава и само тогава когато те са една и съща променлива. (Алтернативно: За всяка променлива `x` е вярно че `x ≡ x`)
2. `¬φ` е синтактично равна на `¬ψ`, тогава и само тогава, когато `φ` е синтактично равна на `ψ`.
3. `(φ1 σ ψ1)` е синтактично равна на `(φ2 σ ψ2)` тогава и само тогава, когато `φ1` е синтактично равна на `φ2` **и** `ψ1` е синтактично равна на `ψ2`, където `σ ∈ {&, ∨, →}`.


**Зад 1. Направете `Prop` инстанция на класа от типове `Eq`, гледайки на `(==)`, като на синтактично (структурно) равенство, както е дефинирано по-горе.**


За да имат смисъл горните синтактични конструкции искаме да можем да им дадем семантика. Това се нарича "оценяване" (**evaluation**)
За да се абстрахираме изцяло от "външни" обстоятелства ние разглеждаме променливите като абстрактни обекти, без изначален смисъл в тях,
давайки им смисъл чрез т.н. "среда" (`Environment`). В една среда всяка променлива `Name` е свързана с булева стойност `Bool`:
```haskell
type Environment = [(Name, Bool)]
```

**Зад 2. Дефинирайте функция**
```haskell
varValue :: Environment -> Name -> Bool
```
**която по дадена среда `e` и променлива `x` намира стойността, "свързана" с `x` в средата `e`.**

За улеснение, приемете `x` винаги има оценка в `e`.

Примери:
```haskell
> varValue [("x", True), ("y", False)] "x"
True
> varValue [("x", True), ("y", False)] "y"
False
```

**Зад 3. Дефинирайте функция**
```haskell
evalWithEnv :: Environment -> Prop -> Bool
```
**която по дадена среда `e` и формула `φ` "оценява" формулата `φ` "в" средата `e`**.

Тук ще използваме нашите изградени досега познания за какво означават различните конструкции на формули:
0. Променливите се оценяват използвайки средата (`varValue`). Константите се оценяват до себе си.
1. `Not` ще съответства на "отрицание", тоест `Not fi` се оценява до `True`, тогава и само тогава, когато `fi` се оценява до `False`.
2. `And` ще съответства на "конюнкция", тоест `And fi psi` се оценява до `True`, тогава и само тогава, когато `fi` **и** `psi` се оценяват до `True`.
3. И т.н.

Примери:
```
> env =  [("x", True), ("y", False)]
> evalWithEnv env $ Var "x"
True
> evalWithEnv env $ Var "x" `And` Var "y"
False
> evalWithEnv env $ (Var "y") `Implies` (Var "x")
True
```

**Зад 4. Дефинирайте функция**
```haskell
allVars :: Prop -> [String]
```
**която по дадена формула `φ` връща всичките променливи на `φ`.**

Пример:
```haskell
> allVars $ Var "x" `And` Var "y" `And` Const True
["x", "y"]
```

**Зад 5. Дефинирайте функция**
```haskell
bind :: [Name] -> [Bool] -> Environment
```
**която по списък от имена и списък от булеви стойности "свързва" покомпонентно всяко име
с всяка булева стойност за да създаде среда.**

Пример:
```haskell
> bind ["x", "y"] [True, False]
[("x", True), ("y", False)]
```

**Зад 6. Дефинирайте функция**
```haskell
allBools :: Int -> [[Bool]]
```
**която по цяло число `n`, генерира всички списъци от `Bool`-ове, с дължина `n`.**

Пример:
```haskell
> allBools 2
[[False, False], [False, True], [True, False], [True, True]]
```

**Зад 7. Дефинирайте функция**
```haskell
allEnvs :: [Name] -> [Environment]
```
**която по списък от имена, генерира "всички възможни средни" с тези имена.**

Тоест всички възможни начини по които можем да оценим имената от списъка.

Пример (форматиран на няколко реда за четимост):
```haskell
> allEnvs ["x"]
[ [("x", False)]
, [("x", True)]
]
> allEnvs ["x", "y"]
[ [("x", False), ("y", False)]
, [("x", False), ("y", True)]
, [("x", True), ("y", False)]
, [("x", True), ("y", True)]
]
```

Една формула `φ`, наричаме "тавтология", ако във всяка възможна среда, `φ` се оценява до истина.

**Зад 8. Дефинирайте функция**
```haskell
isTautology :: Prop -> Bool
```
**която по дадена формула `fi`, връща истина тогава и само тогава, когато `fi` е тавтология по горната дефиниция.**

Примери:
```haskell
> x = Var "x"
> y = Var "y"
> isTautology $ x
False
> isTautology $ x `Or` Not x
True
> isTautology $ x `Or` y
False
```

Една формула `φ`, наричаме "изпълнима" (**satisfiable**), ако съществува среда, в която `φ` се оценява до истина.

**Зад 9. Дефинирайте функция**
```haskell
isSatisfiable :: Prop -> Bool
```
**която по дадена формула `fi`, връща истина тогава и само тогава, когато `fi` е изпълнима по горната дефиниция.**

Примери:
```haskell
> x = Var "x"
> isSatisfiable $ x
True
> isSatisfiable $ x `Implies` Not x
True
> isSatisfiable $ x `And` Not x
False
```

Една формула `φ`, наричаме "противоречие", ако във всяка възможна среда, `φ` се оценява до лъжа.

**Зад 10. Дефинирайте функция**
```haskell
isContradiction :: Prop -> Bool
```
**която по дадена формула `fi`, връща истина тогава и само тогава, когато `fi` е противоречие по горната дефиниция.**

Примери:
```haskell
> x = Var "x"
> isContradiction $ x
False
> isContradiction $ x `And` Not x
True
> isContradiction $ x `Or` Not x
False
```

От `φ` "логически следва" `ψ`, ако във всяка среда в която `φ` се оценява до истина и `ψ` се оценява до истина.

Това традиционно се бележи с `⊨` и се записва `φ ⊨ ψ`. (чете се "от фи логически следва пси")

**Зад 11. Дефинирайте функция**
```haskell
semanticallyImplies :: Prop -> Prop -> Bool
```
**която по дадени формули `fi` и `psi` проверява дали от `fi` логически следва `psi`, по горната дефиниция.**

Примери:

```haskell
> x = Var "x"
> y = Var "y"
> semanticallyImplies x x
True
> semanticallyImplies x y
False
> semanticallyImplies (x `Or` Not x) x
False
> semanticallyImplies x (x `Or` y)
True
> semanticallyImplies (x `And` Not x) y
True
> semanticallyImplies y (x `Implies` x)
True
```

`φ` е "логически еквивалентна" на `ψ`, ако от `φ` логически следва `ψ` и от `ψ` логически следва `φ`.

**Зад 12. Дефинирайте функция**
```haskell
semanticallyEquivalent :: Prop -> Prop -> Bool
```
**която по дадени формули `fi` и `psi` проверява дали от `fi` е логически еквивалентна на `psi`.**

Тук изглеждат лесни имплементациите на тези програми, но в малко по-сложни логики те бързо стават невъзможни (например при ползата на квантори).
Затова за да стигнем до **обективни** (т.е. проверими от компютър) доказателства, ни трябва по-"тъпа" (но по-лесна за следване) схема.

Ще разгледаме следната "очевидна" (и доказуемо вярна) ["аксиомна схема"][axioms]
след което започвайки от тези аксиоми (и евентуално множество от наши формули, които сме приели за верни)
ще следваме едно "очевидно" (и доказуемо вярно) правило, за да строим други доказателства.

Нарича се "аксиомна схема", защото всяка от тези аксиоми не е конкретна – имаме безкрайно много формули които са тяхни "инстанции".
Например следните формули са инстанции на `THEN-1`:
```haskell
x = Var "x"
y = Var "y"

ax1 = x `Implies` y `Implies` x
-- ax1 е инстанция на THEN-1

ax2 = y `Implies` x `Implies` y
-- ax2 също е инстанция на THEN-1

xiy = x `Implies` y

ax3 = xiy `Implies` x `Implies` xiy
-- ax3 също е инстанция на THEN-1
```

**Зад 13. Напишете функция**
```haskell
isAxiom :: Prop -> Bool
```
**която да разпознава инстанции на [аксиомите][axioms] (без `IFF-{1,2,3}`) на езика на нашия тип от данни.**

Примери:
```haskell
> x = Var "x"
> y = Var "y"
> ax1 = x `Implies` y `Implies` x
> ax1
(x → (y → x))
> isAxiom ax1
True                                        -- аксиома по THEN-1
> ax2 = y `Implies` x `Implies` y
> ax2
(y → (x → y))
> isAxiom ax2
True                                        -- аксиома по THEN-1
> xiy = x `Implies` y
> ax3 = xiy `Implies` y `Implies` xiy
> ax3
((x → y) → (y → (x → y)))
> isAxiom ax3
True                                        -- аксиома по THEN-1
> nax1 = xiy `Implies` xiy `Implies` x
> nax1
((x → y) → ((x → y) → x))
> isAxiom $ nax1
False
> xay = xiy `And` xiy
> nax2 =  x `Implies` y `Implies` xay
> nax2
(x → (y → (x → y) & (x → y)))
> isAxiom $ nax2
False
> ax4 = xiy `Implies` xiy `Implies` xay
> ax4
((x → y) → ((x → y) → (x → y) & (x → y)))
> isAxiom $ ax4
True                                        -- аксиома и по AND-1 и по AND-2
> z = Var "z"
> ax5 = xiy `Implies` Not xiy `Implies` z
> ax5
((x → y) → (¬(x → y) → z))
> isAxiom $ ax5
True                                        -- аксиома по NOT-2
> ax6 = (x `Implies` y) `Implies` (x `Implies` Not y) `Implies` Not x
> ax6
((x → y) → ((x → ¬y) → ¬x))
> isAxiom $ ax6
True                                        -- аксиома по NOT-1
```

*Modus ponens* наричаме следното "правило за извод":

Ако знаем, че `φ` е доказана и че и `φ → ψ` е доказана, то тогава можем да докажем и `ψ`.

Това традиционно се нарича "формално следствие" и се бележи с `⊢` (**turnstile**).

Записано традиционно: `φ, φ → ψ ⊢ ψ` (чете се "от фи и от фи импликация пси **формално следва** пси").

**Зад 14. Дефинирайте функция**
```haskell
modusPonens :: Prop -> Prop -> Prop -> Bool
```
**която по дадени формули `fi`, `psi` и `hi` проверява дали от `fi` и `psi` следва (по *modus ponens*) `hi`**.

Примери:
```haskell
> x = Var "x"
> y = Var "y"
> modusPonens x (x `Implies` y) y
True
> modusPonens x (x `Implies` y) x
False
> modusPonens (x `And` y) (x `Implies` y) y
False
```

**Доказателство от множество от формули `Γ` ("хипотези")** наричаме редица (списък) от формули `[φ0, φ1 .. φn]`, такава че:

За всяко `j <= n` е изпълнено:
1. `φj` е аксиома (`isAxiom`) или е от множеството `Γ`.
2. `φj` формално следва по *modus ponens* от "предишни" `φp`, `φq`. (т.е. има индекси `p < j` и `q < j`, такива че `φp, φq ⊢ φj`),
(т.е. `φq` е `φp → φj`)

Обикновено казваме също така че `[φ0, φ1 .. φn]` е доказателство за `φn` (последната формула на доказателството) от `Γ`.

**Зад 15. Дефинирайте функция**
```haskell
proofFrom :: [Prop] -> [Prop] -> Bool
```
**която по дадени множество от формули `gamma`, и списък от формули `proof` проверява дали `proof` е валидно доказателство от `gamma` (по горната дефиниция).**

Примери:
```haskell
> magicPrint = mapM_ print -- не е важно, само за принтене с нови редове

-- симетричност на конюнкцията - ако допуснем че x `And` y, то тогава y `And` x
> hypSymAnd = [x `And` y] -- допускаме x & y
> symAnd = [ x `And` y `Implies` x
           , x `And` y `Implies` y
           , x `And` y
           , y
           , x
           , y `Implies` x `Implies` y `And` x
           , x `Implies` y `And` x
           , y `And` x -- доказахме y & x
           ]
> proofFrom hypSymAnd symAnd
True
> magicPrint symAnd -- === РАЗЯСНЕНИЕ ===
(x & y → x)         -- (0) инстанция на AND-1
(x & y → y)         -- (1) инстанция на AND-1
x & y               -- (2) елемент на hypSymAnd
y                   -- (3) следва от (2) и (1) по modus ponens
x                   -- (4) следва от (2) и (0) по modus ponens
(y → (x → y & x))   -- (5) инстанция на AND-2
(x → y & x)         -- (6) следва от (3) и (5) по modus ponens
y & x               -- (7) следва от (4) и (6) по modus ponens

-- i е доказателство за "рефлексивност" на импликацията, x `Implies` x
> i = [ ((x `Implies` ((y `Implies` x) `Implies` x)) `Implies` ((x `Implies` (y `Implies` x)) `Implies` (x `Implies` x)))
      , (x `Implies` ((y `Implies` x) `Implies` x))
      , ((x `Implies` (y `Implies` x)) `Implies` (x `Implies` x))
      , (x `Implies` (y `Implies` x))
      , (x `Implies` x)
      ]
> proofFrom [] i
True
> magicPrint i                                    -- === РАЗЯСНЕНИЕ ===
((x → ((y → x) → x)) → ((x → (y → x)) → (x → x))) -- (0) инстанция на THEN-2 в която fi = x, chi = y `Implies` x, psi = x
(x → ((y → x) → x))                               -- (1) инстанция на THEN-1 в която fi = x, chi = y `Implies` x
((x → (y → x)) → (x → x))                         -- (2) следва от (1) и (0) по modus ponens
(x → (y → x))                                     -- (3) инстанция на THEN-1 в която fi = x, chi = y
(x → x)                                           -- (4) следва от (3) и (2) по modus ponens
```

**БОНУС(много трудноооооо) Зад 16. Дефинирайте функция**
```haskell
prove :: [Prop] -> Prop -> Maybe [Prop]
```
**която по множество от формули `Γ` и формула `φ`, връща `Just xs`, ако има такова `xs`, което е доказателство (по горната дефиниция) за `φ` от `Γ` и `Nothing`, ако няма такова.**

[Haskell info]:../notes/02-useful-info-haskell.md
[README.md]:../README.md
[axioms]:https://en.wikipedia.org/wiki/Propositional_calculus#Axioms
[modus ponens]: https://wikimedia.org/api/rest_v1/media/math/render/svg/1b04d6ec55879b9dc88eeb1458ec4710012bfb2c

